# Net Raid FS

## ზოგადი აღწერა
პროგრამა წარმოადგენს ქსელურ იერარქიულ ფაილურ სისტემას, რომელიც  RAID1 სქემის მიხედვით ახდენს მონაცემების განაწილებას და დაცვას.

კლიენტი მის მიერ მითითებულ დირექტორიაში ამაუნთებს ქსელის გავლით მიწვდომად დირექტორიას(დირექტორიებს), რომელიც ორ სერვერზე დუბლირებულ ფაილურ სისტემას წარმოადგენს. კლიენტის მიერ მოთხოვნილი ფაილები ქსელის გავლით წამოვა სერვერებიდან, დამაუნთებულ დირექტორიაში მომხდარი ყველა ცვლილება აისახება სერვერების დირექტორიებშიც. თავად სერვერის მისამართები და პორტები წერია configfile-ში. კლიენტს ასევე შეუძლია რამდენიმე დირექტორია დაამაუნთოს სხვადასხვა სერვერებზე.


სერვერის მხარე მუშაობს RAID1 ის პრინციპით. თითოეული საცავისთვის  გაშვებულია 2 სერვერი, თითო საკუთარი დირექტორიით. ამ დირექტორიებში დუბლირებულია კლიენტის დამაუნთებული დირექტორია და  stable storage მექანიზმით ახდენენ დაზიანუბული ფაილების აღმოჩენას და შესწორებას(იხ. ქვემოთ). ასევე არსებობს დამატებითი სერვერი, ე.წ. hotswap სერვერი რომელიც რომელიმელშიც სერვერის გათიშვის შემთხვევაში გადაიწერება გადარჩენილი სერვერის მთლიანი საცავი.

## პროგრამის გაშვება
კლიენტის გაშვება: ./net_raid_client /path/to/config_file

სერვერის(სერვერების გაშვება) გაშვება:	./net_raid_server 127.0.0.1 10001 /path/to/storage_dir1
					./net_raid_server 127.0.0.1 10002 /path/to/storage_dir2


configfile-ს აქვს შემდეგი სახე:

	errorlog = /path/to/error.log
	cache_size = 1024M
	cache_replacment = rlu
	timeout = 10

	diskname = STORAGE1
	mountpoint = /path/to/mountpoint1
	raid = 1
	servers = 127.0.0.1:10001, 127.0.0.1:10002
	hotswap = 127.0.0.1:11111 

	diskname = STORAGE2
	mountpoint = /path/to/mountpoint2
	raid = 5
	servers = 127.0.0.1:10011, 127.0.0.1:10012, 127.0.0.1:10013
	hotswap = 127.0.0.1:22222


net_raid_serverის ვაგრანატში გაშვების შემთხვევაში საჭიროა სანახი დირექტორიები იყოს /home დირექტორიაში, რადგან პროგრამა იყენებს extended attribute-ებს. ასევე სასურველია net_raid_serverის გაშვება მოხდეს sudo su კომანდით. ამასთან ერთად, რადგან პროგრამა იმპლემენტირებს ჰოტსვაპის მექანიზმს, საჭიროა ჰოტსვაპის სერვერის დირექტორია იყოს ცარიელი, საწინააღმდეგო შემთხვევაში, პროგრამა დააფიქსირებს მას და დაეგზიტდება -1 სტატუსით.
ამასთან ერთად პარსის ბუნებიდან გამომდინარე სასურველია config.file-ს ბოლო ხაზი არ იყოს ცარიელი.

## არქიტექტურა
### სერვერის მხარე
სერვერი კლიენტთან კავშირის დამყარების შემდეგ ტრიალებს while(1) ციკლში და ელოდება მისგან რიქვესთებს. კონკრეტული რეიქვესთის მიღების შემდეგ იძახებს მის შესაბამის `handle()` ფუნქციას. პროტოკოლის შესახებ უფრო დეტალურად ვისაუბრებ. გადატვირთული სისტემქოლებია:open, read, write, release, rename, unlink, rmdir, mkdir, opendir, releasedir, mknod, getatt, utime, truncate, lock.

### პარსი და დამაუნთება
პროგრამის ძირითადი ლოგიკა კლიენტში დევს. net_raid_client-ის გშვებისთანავე შეილებ ითქვას პარალელურად ხდება. თითო მაუნთფოინთის შესაფერისი ბლოკის დაპარსვის შემდეგ, დატა ინახება სტატიკურ ცვლადებში:
```
static char error_log[1024];
static int cache_size;
static char cache_replacment[256];
static int timeout;
static char diskname[256];
static char mountpoint[1024];
static int raid;
static char server1[256];
static char server2[256];
static char hotswap[256]
```
როდესაც ერთი ბლოკის წაკითხვის შემდეგ ინფორმაცია ამ ველებში დაისეტება კლიენტი იძახებს `fork()`-ს. მიღებულ შვილობილ პროცესში ამ სტატიკურ ცვლადებში დასეტილი ინფორმაცია შეესაბამება მის შესაფერის მაოუნთფოინთის პარამეტრებს. ის შემდეგ იძახებს `fuse_main`-ს, და რადგან ეს ფუნქცია თავად ფორკავს პროცესს და ბექგროუნში გადაყავს, fuse_main-ის გამოძახების შემდეგ ეგზიტდება. ფორკის ბუნებიდან გამომდიარე საჭირო პარამეტრები შენახულია საბოლოოდ მიღებულ შვილობილ პროცესში. ეს მეორდება config file-ის თითოეული ბლოკისთვის.

### პროტოკოლი სერვერსა და კლიენტს შორის
როგორც წეღან ვახსენე, სერვერი მუდმივად ელოდება კონკრეტული ფუნქციის შესაბამის რიქვესთს. `request.h`-ში აღწერილია თითუელი ფიუზის მიერ გადატვირთული ფუნქციების შესაბამისი რიცხვი. თითქმის ყველა ფიუზის ქოლი თავდაპირელად ერთსა და იმავე სინფორმაციას გაზვნის:
1. სისქოლის შესაბამისი რიქვესთის რიცვი
2. ფაილის/დირექტორიის შესაბამისი path-ის სიგრძე.
ანუ მოკლედ რო ვთქვათ, ჯერ იგზავნება მინიშმება იმაზე, თუ რამდენი ბაიიტის წაკითხვა უნდა მოხდეს სოკეტიდან მომავალში. თუ პროტოკოლის ეს ეტაპი წარმატებით სადრულდა უკვე ხდება თავად კონტენტის გაგზავნა/მიღება char-ის ბაფერების მეშბეობით, რომლებშიც შედის მაგალითად თავად path, ან stbuf-ები. ყოველი შემთხევისთვის სასვებით შესაძლებელია რამდენიმე სტურტურა ერთად გადაიგზანოს სერვერზე სადაც ამ ბაფერიდად სწორად ამოიღება სტრუქტურები.
კომუნიკაცია ხდება `read()`და `write()` სისტემქოლების გამოყენებით.

### raid 1, ორ სერვერთან კომუნიკაცია
სისტემქოლების ნაწილი, როგორიცაა mknod, mkdir, truncate და სხვები, ანუ ქოლები რომლებიც სერვერზე შემდგენლობას ცვლიან, მაგრამ არ აწარმოებენ write-ს, ხდება პარალელურად. fuse-ის გადატვურთული ფუქნციებიდან ამ შემთხვევაში ბრუნდება ის ნებისმიერ ქოლი რომელიც წარმატებიტ დასრულდა. ქოლები როგორიცაა read და readdir, ანუ ისინი, რომელბიც მოითხოვენ სერვერიდან ინფორმაციას, ცდილობენ ეს ინფორმაცია მოითხოვონ მხოლოდ ერთი სერვერიდან და მხოლოდ გაწყვეტილი კავშირის შემთხვევაში მიმართავენ მეორეს. გამონაკლისია gettatr, რომელიც მეორე სერვერს მიმართავს არა მხოლოდ გაწყვეტილი კავშირის მიზეზით, არამედ ფაილის არარსებობის შემთხვევაშიც(მცირე დეტალი დეგრადირებულ რეჟიმში მუშაობასთან დაკავშირებით). ასევე გამოკალისია write ქოლი, რომელიც პირველის წარუმატებლობის შემთხვევაში, თუ მიზეზი არის სერვერთან დაკარგული კავშირი, მიმართავს მეორე სერვერს(ამაზე უფრო მეტი  დეგრადირებული რეჟიმის შესახებ), თუ არა,საერთოდ არ აგრძელებს წერას. open ქოლიც ეგზავნება სერვერებს პარალელურად, მაგრამ თითო პარალელური ფუნქციების დაბრუნებული შედეგი მუშავდება(ამაზე მოგვიანებით).

- note: read სისტემქოლს შეიძლება გადმოეცემოდეს ბაფერი, რომელის ზომაც მილიონს აღწერს. ამდენი ბაიტის კითხვა სოკეტს არ შეუძლია, ამიტომ read სისტემქოლის დროს ინფორმაციის მიმოცვლა ბეფერში იხლიჩება 4096 ბაიტებად. ეს გვაძლებს დიდ ფაილებთან მუშაობის საშუალებას.
#### პარალელიზმისთვის გამოეყენებული სტურქტურები და ალგორითმები.
გამოიყენება POSIX-ს სრედები. ფუნქციებს, რომელიბიც რეალურად გადატვირთული სისქოლის საქმეს ასრულებს მაგრამ გათვლილია ერთ სერვერზე ცალკე სრედით, იწყება `para` წინსართით. თვითონ გადატვირთული ქოლები იძახებენ `static int request_paralel(para_func func, struct para_info** info)`,`func`-ის აგდილზე სეტავენ შესაბამის `para_` ფუქნციას და ატანენ para_info სტრუნქტურაზე მიმთითებელს. `para_info` სტურქტურა გამოიყურება ასე:
```
struct para_info{
	int sfd;
	int num;
	const char* path;
	void* buf;
	int size;
	off_t offset;
	struct stat* stbuf;
	struct fuse_file_info* fi;
	off_t newsize;
	mode_t mode;
	dev_t dev;
	const char* newpath;
	int* ret_val;
	struct utimbuf* ubuf;
	struct flock *lock;
	int cmd;
	unsigned char* hash;
};
```
ის შეიცავს ყველა შესაძლო პარამეტს რაც ქოლისთვის უნდა გამოიყენებოდეს, შესაბამისად შვილობის სრედს ამ სტრუქტურაში საჭირო პარამეტებ დასეტილი para_info სტრუქტურა გადაეცემა.

### stable storage
როგორც ზოგადაგ stable storage-ისთვის არის საჭირო, ფაილებს ენახებათ მისი კონტენტის მიხედვით დათვლილი ჰეშები, დაზიანებული ფაილის აღმოჩენა ხდებ ჰეშის მეშვეობით. პროგრამაში გამოყენებულია md5 ალგორითმი, `mdr5.c` და `md5.h`ფაილებში. მოცემული კოდის წყაროა: https://openwall.info/wiki/people/solar/software/public-domain-source-code/md5 რომელიც სანდო public domain იმპლემენტაციას წარმოადგენს. 

#### მუშაობის პრინციპი
- write ქოლის ყოველი გამოძახების შემდეგ, ფაილის მთლიანი კონტენტისთვის ითვლება ჰეში. ამ ეტაპზე არ ხდება არანაირი შემოწლება დაზიანებული ფაილების აღმოსაჩენად.

- open ქოლის დროს, როგორც საჭიროა, ხდება დაზიანებული ფაილების აღმოჩენა. `para_open()` ცალ ცალკე და პარალელურად ეშვევა. სერვერის მხარეს ახლიდან ხდება მთლიანი ფაილის ჰეშის დათვლა და ხდება ორივეს მიერ დაბრუნებული შედეგის დამუშავება `static int process_responses(int res1, int res2, unsigned char* hash1, unsigned char* hash2)` ფუნქციის მეშვეობით. თითო res ცვლადი შეიცავს ინფორმაციას, იმის შესახებ დაემთხვა თუ არა ჰეში ფაილს(ასევე მოხდა თუ არა ფაილში ერთი write მაინც დეგრადირებულ რეჟიმში, ამაზე მოგვიანებით), ან მოხდა თუ არა რაიმე ერორი. ასევე `hash_cmp()` ფუნქციის მეშვეობით ხდება ორი ჰეშის შედარება და როგორც stable storage ალგორითმი მიუთითებს ხდება ფაილის აღდგენა ერთი სერვერიდან მეორეში. ამ გადატანისთვის გამოიყენება `static int transfer_file(int sender, int reciever)` ფუნქცია. 

### სერვერებთან კავშირი
პროგრამის მუშაობისას მუდმივად გაშვებული არის ნაკადი, რომელიც წამში ერთხელ HEALTHCHECK რიქვესთსგზავნის ორივე სერვერთან. წარუმატებლობის შემთხვევაში იწყევს წამების ათვლას, თითო ჯერზე ახლიდან ეცდება `socket_connect()`ის მეშვებოით სერვერთან კავშირის აღდგენას. თუ ათვლა მიაღწევს კონფიგურაციის ფაილში მითითებულ წამების რაოდენობას, ხდება ჰოტსვაპის მექანიზმის ჩართვა. 
ლოგიკურია რომ კლიენტში ორი სრედის არსებობის გამო, რომლებიც ორივე ერთსა და იმავე სერვერებთან კომუნიცირებენ შეიქმნება სინქრონიზაციის პრობლემა, ამიტომ როგორც სერვერთან კავშირის შემმოწმებელი ფუნციაა, ასევე გადატვირთული ქოლები წარმოადგენენ კრიტიკულ სექციებს რომელიც დალოქილია მუტექსით `lock`.

### დეგრადირებულ რეჟიმში ჩაწრილი ფაილები
- თავდაპირველად შენიშვნა: ამოცანის პირობაში ყურადღება გამახვილებულია ასეთ რეჟიმში ფაილებში წერაზე, თუ ამ დროის შესაძლებელია ფიალების/დირექტორიების შექმნა და წაშლა ძალიან ბევრი ინფორმაციის შენახვა და დამახსოვრება გვიწევს. ან იძUლებულები ვართ ინფორმაცია შევინახოთ კლიენტში, რაც არასწორია, რადგან კლიენტის გათიშვის შედეგად ყველანაირი ინფრომაცია გვეკარგება; ან კავშირის აღდგენის შედეგად დაკარგული სერვერი უნდა გაიწმინდოს და სრულიად გადმოკოპირდეს ცოცხალი სერვერიდან სანახი, რაც ჩემი აზრით ასევე არაოპტიმალურია, განსაკუთრებით მაშინ თუ ხშირეად ხდება კავშირის გაწყვეტები, სანახის გადატანა კი საკმაოდ შრომატევადია, ასევე ის ეწინააღმდეგება პირობაში მითითებულ მითხოვნას, რომ ამ რეჟიმში მომხდარი ცვლილებიბი აღმოჩნდეს open სისტემქოლის მეშვეობით; და ასევე შესაძლებელია ამ პრობლემის მოგვარება extended ატრიბუტების სახით, ეს უკანასკლენი მე ნაწილობრივ მაქვს იმპლემენტირებული.

პირობაში რაც არის მოთხოვნილი, რომ დეგრედირებულ რეჟიმებში ჩაწერილი ფაილები აღდგენ openსისტემქოლის გამოყენებით, სრულად არის იმპლემენტირებული. ასევე თუ უიზერი ამ რეჟიმში შექმნის ფაილს და მასში ჩაწერს დატას, სერვერის აღდგენის შემდეგ ეს ფაილი შეიქმნება და კონტენტი ჩაიწერება. ეს ხდება შემდეგნაირად: ფაილის შექმნის მომენტიდანვე მას ესეტება 0 extended ატრიბუტად "user.degraded". რადგან write ქოლები თითო სერვერისთვის გამოიძახება მიმდევრობით, თუ პირველ სერვერს კავშირის გაწყვეტა დაუფიქსირდა, მეორე სერვერზე ამ ატრიბუტში დაისეტება 1. ანუ რეალურად ვინახავთ ერთი მაინც write თუ მოხდა ამ სერვერზე, რომელიც მეორზე არ მომხდარა. open სისტემქოლის დროს გათვალისწინებული ეს შემთხვევა და ხდება მისი დამუშავება იმის გასარკვევად თუ რომელი სერვერიდან რომელზე უნდა იყოს გადატანილი ფაილი. ფაილის გადატანის შემდეგ ატრიბუტად კვალვ 0 ისტებე. open ამუშავებს ფაილების მდგომაროებას ისე, რომ შესაძლებელი იყოს ამ მექანიზმის შერწყმა stable storage-თან. მაგალითად თუ პირველ სერვერთან გაწყდა კავშირი და მეორეზე მოხრა როგორც დეგრადირებულ რეჟიმში ფაილის ასევე ჰეშტან შეუსაბამობა, აღდგება პირველ სერვერზე არსებული ძველი ვერსია. თუ დეგრეადირებულ რეჟიმში ჩაწერა არ დაფიქსირებულა, ჩვეულებრივად მუშაობს stable storage.

არ არის გათვალისწინებული ფაილების/დირექტორიების წაშლა და დირექტორიების შემქნა.
წაშლის დაფიქსირებაც სავარაუდოდ შესაძლებელი იქნებოდა extended ატრიბუტების სახით, თუმცა ამ შემთხვევაში შეუძლებელი იქნებოდა ფაილების და დირექტორიების პარალელურად შექმნა და ასევე სავარაუდოდ მოითხობდა გარკვეული დონის კომპლექსურობას. ვივარაუდებ პირობიდან გამომდინარე რომ ეს ფიჩერი არ მოგვეთხოვებოდა.


### ჰოტსვაპი
ჰოტსვაპის მექნიზმი საკმაოდ პირდაპირია.timeout წამის შედეგ სერვერთან კავშირის აღუდგენლობის შედეგად გამოიძახება `static int add_hotswap(int sender, int* reciever)` ფუქნცია. რომელიც:
- ამყარებს კავშირს ჰოტსვაპის სერვეთან
- დაკარგული სერვერის შესაბამის პარამეტრებს ანაცვლებს ჰოტსვაპის პარამეტრებით
- ჰოტსვაპთან გზავნის მოსალოდნელი სანახის მიღების რიქვესთს
- ცოცხალ სერვერთან გზავნის სანახის გამოგზავნის მოტხოვნის რიქვესთს
- იძახებს `static int transfer_storage(int sender, int reciever)` ფუნქციას. ამ დროს ცოცხალი სერვერი რეკურსიულად გადაუყვება მის კონტენტს და უგზავნის კლიენტს. კლიენტი კი მას ყოფილ ჰოტსვაპის სერვერთან აგზავნის. როგორც უკვე ავღნიშნე, ჰატსვაპის სანახის არა-სიცარიელის შემთხვევაში პროცედურა წყდება და კლიენტი ეგზიტდება.
- სანახის გადატანის პროცედური დროს კლიენტი დაბლოკილია.

### ლოგირება
ლოგირების ფუნქციები აღწერილია `log.c` და `log.h` ფაილებში. თითოეული დასამაინთებელი ბლოკისთვის, დაფორკვის შემდეგ გამოიძახება `void log_init(char* path, char* storage_name);` ფუქნცია, რომელსაც გადაცემა ლოგის ფაილის მისამართი და ბლოკის შესაბამისი სანახის სახელი. ეს ინფორმაცია ინახება და გამოიყენება ლოგის ფორმატისთვის. შემდეგ თითოული მესიჯი გამოიტანება `int raid_log(char* ip_port, const char* msg)` ფუნქციის მეშვეობით. გათვალიწინებულია შემთხვევები რომელიც ილოგება:
- დასტარტვისას სერვერთან კავშირის დამყარება
- სერვერის დაკარგვა
- სერვერის აღდგენა
- ჰოტსვაპთან კავშირის დამყარება
- ჰოტვაპთან კავშირის ვერ დამყარება
- ჰოსტვაპისას სანახის სრული გადაკოპირება
- სანახის გადაკოპირებისას წარუმატებლობა
- ორ სერვერზე ფაილებს შორის არაკონსისტენტურობის დაფიქსირება
- ფაილის მიღების მოთხოვნა
- ფაილის გაგზავნის მოთხოვნა
- ფაილის გაგზავნის ერთი სერვერიდან მეორეზე წარმატებით დასრულება 

